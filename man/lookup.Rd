% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lookup.R
\name{lookup}
\alias{lookup}
\alias{lookup.list}
\alias{lookup.data.frame}
\alias{lookup.matrix}
\alias{lookup.numeric}
\alias{lookup.factor}
\alias{lookup.character}
\alias{\%l\%}
\alias{\%l+\%}
\alias{\%lc\%}
\alias{\%lc+\%}
\title{Hash Table/Dictionary Lookup
 
\code{lookup} - \href{http://datatable.r-forge.r-project.org/}{\pkg{data.table}} 
based hash table useful for large vector lookups.}
\usage{
lookup(terms, key.match, key.reassign = NULL, missing = NA)

\method{lookup}{list}(terms, key.match, key.reassign = NULL, missing = NA)

\method{lookup}{data.frame}(terms, key.match, key.reassign = NULL, missing = NA)

\method{lookup}{matrix}(terms, key.match, key.reassign = NULL, missing = NA)

\method{lookup}{numeric}(terms, key.match, key.reassign, missing = NA)

\method{lookup}{factor}(terms, key.match, key.reassign, missing = NA)

\method{lookup}{character}(terms, key.match, key.reassign, missing = NA)

terms \%l\% key.match

terms \%l+\% key.match

terms \%lc\% key.match

terms \%lc+\% key.match
}
\arguments{
\item{terms}{A vector of terms to undergo a lookup.}

\item{key.match}{Takes one of the following: (1) a two column data.frame of a 
match key and reassignment column, (2) a named list of vectors (Note: if 
data.frame or named list supplied no key reassign needed) or (3) a single 
vector match key.}

\item{key.reassign}{A single reassignment vector supplied if key.match is 
not a two column data.frame/named list.}

\item{missing}{Value to assign to terms not matching the key.match.  If set 
to \code{NULL} the original values in \code{terms} corresponding to the 
missing elements are retained.}
}
\value{
Outputs A new vector with reassigned values.
}
\description{
\code{\%l\%} - A binary operator version of \code{lookup} 
for when \code{key.match} is a data.frame or named list.

\code{\%l+\%} - A binary operator version of \code{lookup} 
for when \code{key.match} is a data.frame or named list and \code{missing} is
assumed to be \code{NULL}.

\code{\%lc\%} - A binary operator version of \code{lookup} 
for when \code{key.match} is a data.frame or named list and all arguments are 
converted to character.

\code{\%lc+\%} - A binary operator version of \code{lookup} 
for when \code{key.match} is a data.frame or named list, \code{missing} is
assumed to be \code{NULL}, and all arguments are converted to character.
}
\examples{
## Supply a dataframe to key.match

lookup(1:5, data.frame(1:4, 11:14))

## Retain original values for missing 
lookup(1:5, data.frame(1:4, 11:14), missing=NULL) 

lookup(LETTERS[1:5], data.frame(LETTERS[1:5], 100:104))
lookup(LETTERS[1:5], factor(LETTERS[1:5]), 100:104)

## Supply a named list of vectors to key.match

codes <- list(
    A = c(1, 2, 4), 
    B = c(3, 5),
    C = 7,
    D = c(6, 8:10)
)

lookup(1:10, codes)

## Supply a single vector to key.match and key.reassign

lookup(mtcars$carb, sort(unique(mtcars$carb)),        
    c("one", "two", "three", "four", "six", "eight")) 
    
lookup(mtcars$carb, sort(unique(mtcars$carb)),        
    seq(10, 60, by=10))
  
## \%l\%, a binary operator version of lookup
1:5 \%l\% data.frame(1:4, 11:14)
1:10 \%l\% codes

1:12 \%l\% codes
1:12 \%l+\% codes
  
(key <- data.frame(a=1:3, b=factor(paste0("l", 1:3))))
1:3 \%l\% key

##Larger Examples
key <- data.frame(x=1:2, y=c("A", "B"))
big.vec <- sample(1:2, 3000000, TRUE)
out <- lookup(big.vec, key)
out[1:20]

## A big string to recode with variation
## means a bigger dictionary
recode_me <- sample(1:(length(LETTERS)*10), 10000000, TRUE)

## Time it
tic <- Sys.time()  

output <- recode_me \%l\% split(1:(length(LETTERS)*10), LETTERS)
difftime(Sys.time(), tic)

## view it
sample(output, 100)
}
\seealso{
\code{\link[data.table]{setDT}},
\code{\link[qdapTools]{hash}}
}
